//HintName: TestAttribute.g.cs
// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

partial class TestAttribute
{
    public const string ATTRIBUTE_NAME = "OtherNamespace.Here.OtherNameAttribute";

    public static void AddTo(IncrementalGeneratorPostInitializationContext context)
    {
        const string hintName = "OtherNamespace.Here.OtherNameAttribute.g.cs";
        const string code = @"using System;

namespace OtherNamespace.Here
{
    [AttributeUsage((AttributeTargets)32767, AllowMultiple = false, Inherited = true)]
    public class OtherNameAttribute : Attribute
    {
        public OtherNameAttribute(string requiredArgument) { }
        public int OptionalArgument { get; set; }
    }
}
";
        var sourceText = SourceText.From(code, new UTF8Encoding(false));
        context.AddSource(hintName, sourceText);
    }

    public static TestAttribute From(AttributeData data)
    {
        var namedArguments = data.NamedArguments.ToDictionary(o => o.Key, o => o.Value);
        var ___requiredArgument = (string)data.ConstructorArguments[0].Value!;
        var ___optionalArgument = GetNamedValueOrDefault<int>("OptionalArgument", 42);
        return new(requiredArgument: ___requiredArgument, optionalArgument: ___optionalArgument);
        T GetNamedValueOrDefault<T>(string name, T defaultValue) => namedArguments.TryGetValue(name, out var value) ? (T) value.Value! : defaultValue;
    }

    public static bool TryFrom(AttributeData data, [NotNullWhen(true)] out TestAttribute? parsedData)
    {
        try
        {
            parsedData = From(data);
            return true;
        }
        catch
        {
            parsedData = default;
            return false;
        }
    }

    public static IncrementalValuesProvider<T> Find<T>(
        SyntaxValueProvider syntaxValueProvider,
        Func<SyntaxNode, CancellationToken, bool> predicate,
        Func<GeneratorAttributeSyntaxContext, IReadOnlyList<TestAttribute>, CancellationToken, T> transform)
        => syntaxValueProvider.ForAttributeWithMetadataName(
            ATTRIBUTE_NAME,
            predicate,
            (context, cancellationToken) =>
            {
                var attributes = (IReadOnlyList<TestAttribute>) context.Attributes
                    .Select(data =>
                    {
                        var result = TryFrom(data, out var attribute);
                        return (result, attribute);
                    })
                    .Where(pair => pair.result)
                    .Select(pair => pair.attribute!)
                    .ToList();
                return (context, attributes);
            })
            .Where(pair => pair.attributes.Any())
            .Select((pair, ct) => transform(pair.context, pair.attributes, ct));
}
